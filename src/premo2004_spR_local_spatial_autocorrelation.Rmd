---
title: "Premo 2004 - Reproduced Research"
subtitle: "Local spatial autocorrelation"
author: "Domenico Giusti"
bibliography: "../doc/premo2004_rr.bib"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Reading data

```{r}
# read csv
setwd("~/project/premo2004_rr/")
X <- read.csv("data/Premo2004_table1.csv", header=TRUE, sep=",", skip=0)
```

```{r}
# convert to SpatialPointDataframe
library(sp)
coo <- X[,c(4,3)]
spX <- SpatialPointsDataFrame(coo, X, proj4string=CRS(as.character(NA)))
```

```{r}
coords <- coordinates(spX)
id <- row.names(as(spX, "data.frame"))
```

## 4. Spatial data and methods

```{r}
# table 1
library(knitr)
kable(X)
```

> Table 1 presents the spatial data used in this analysis. Note that it includes the same 47 sites that Bove[2], Whitley and Clark[19], Kvamme[7], and Williams[20] analyzed. [@Premo2004]

```{r}
# fig.0
library(ggplot2)
ggplot(data=X, aes(x=Easting..km., y=Northing..km., col=Date..AD.)) + geom_point() + coord_fixed(ratio=1) + theme_bw() + xlab("Km East") + ylab("Km North") + ggtitle("Fig.0")

# fig.1
```

> Fig.1. Fourth order trend surface with terminal long-count date locations. Map values are in years AD. Sites are numbered consecutively and identified by name in Table 1. [@Premo2004]

### Spatial autocorrelation

```{r}
# > spdep â€“ sp.correlogram, moran, moran.plot, moran.test, moran.mc. This is the most comprehensive package, and also the most difficult to work with. Does everything, has steep learning curve. (https://www.r-bloggers.com/spatial-correlograms-in-r-a-mini-overview/)
library(spdep)
```

#### Spatial neighbours

> The first step is to define which relationships between observations are to be given a non-zero weight, that is to choose the neighbour criterion to be used [@Bivand2008, p.239]

```{r}
# graph-based neighbours
# > Note that graph-based representations contruct the interpoint relationships based on Euclidean distance, with no option to use Great Circle distances for geographical coordinates. [@Bivand2008, p.244]
library(tripack)
## Delauney triangulation neighbours
X_del <- tri2nb(coords, row.names=id)
X_del <- deldir::deldir(as.data.frame(coords), plotit=TRUE)
## Sphere of Influence neighbours
X_soi <- graph2nb(soi.graph(X_del, coords), row.names=id)
## Gabriel graph neighbours
X_gab <- graph2nb(gabrielneigh(coords), row.names=id)
## Relative graph neighbours
X_rel <- graph2nb(relativeneigh(coords), row.names=id)
### plot
plot(X$Easting..km., X$Northing..km.)
plot(X_del, add=TRUE)
plot(X_gab, coords, add=TRUE)

# distance-based neighbours
# > An alternative method is to choose the k nearest neighbours [...] knearneigh can also take a longlat argument to handle geographical coordinates. [@Bivand2008, p.246]
## k nearest neighbour
X_kn1 <- knn2nb(knearneigh(coords, k=1), row.names=id)
X_kn2 <- knn2nb(knearneigh(coords, k=2), row.names=id)
X_kn4 <- knn2nb(knearneigh(coords, k=4), row.names=id)
## nearest neighbour based on a specified distance
# > The k=1 object is also useful in finding the minimum distance at which all areas have a distance-based neighbour. [@Bivand2008, p.246]
dis <- unlist(nbdists(X_kn1, coords))
summary(dis)
X_kd1 <- dnearneigh(coords, d1=0, d2=1*max(dis), row.names=id)
## nearest neighbour by row distance
X_nb25 <- dnearneigh(coords, d1=0, d2=25, row.names=id)
X_nb50 <- dnearneigh(coords, d1=0, d2=50, row.names=id)
X_nb75 <- dnearneigh(coords, d1=0, d2=75, row.names=id)
### plot
plot(X$Easting..km., X$Northing..km.)
plot(X_nb75, coords, add=TRUE)

# higher-order neighbours
# > Distance bands can be generated by using a sequence of d1 and d2 argument values for the dnearneigh function if needed to construct a spatial autocorrelogram as understood in ecology. In other conventions, correlograms are constructed by taking an input list of neighbours as the first-order sets, and stepping out across the graph to [...] higher-order neighbours [@Bivand2008, p.249]
X_nb_lags <- nblag(X_kn1, maxlag=8)
```

#### Spatial weights

> [...] the second is to assign weights to the identified neighbour links [@Bivand2008, p.239]

> In the same way that the choise of the criteria to define neighbours may affect the results in testing or modelling of the use of weights constructed from those neighbours, results maybe also be changed by the choise of weights style. [@Bivand2008, p.253]

```{r}
# > The nb2listw function takes a neighbours list object and convert it into a weights object. The default conversion style is W, where the weights for each areal entity are standardised to sum to unity [@Bivand2008, p.251]
# > The spatial weight matrix used in the present analysis is binary. [@Premo2004]
# B style (binary)
X_lw_B <- nb2listw(X_nb75, style="B")
```

#### Spatial autocorrelation: global tests

```{r}
# global tests
## Moran's I
moran.test(spX$Date..AD., listw=nb2listw(X_nb25), zero.policy=TRUE, adjust.n=TRUE)
## >
moran.test(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))
## Geary's C
## Getis-Ord G
```

```{r}
# correlograms
## Moran's I for lag orders
X_cor8 <- sp.correlogram(neighbours=X_nb25, var=spX$Date..AD., order=8, method="I", style="W")
X_cor3 <- sp.correlogram(neighbours=X_nb25, var=spX$Date..AD., order=3, method="I", style="W", zero.policy = TRUE)
print(X_cor3, p.adjust.methods="holm")
plot(X_cor3)
## Moran's I for distance bands
library(pgirmess)
X_corD <- correlog(coordinates(spX), spX$Date..AD., method="Moran")
print(X_corD)
plot(X_corD)
```

```{r}
# global Moran scatterplot
moran.plot(spX$Date..AD., listw=nb2listw(X_nb75, style="W"), labels=as.character(spX$Site.number))
```

#### Spatial autocorrelation: local tests

> Standardized Ii and Gi variates were calculated for lag distances up to and including 200 km at 25 km intervals (Table 2). [@Premo2004]

```{r}
# local Moran's I
# > Like its global predecessor, local I measures the degree to which a target value is similar to the values displayed by adjacent locales. Unlike global I, however, the local version measures the similarity between each target value and the values within its neighborhood. [...] Local Moran's I is large and positive when Xi is similar to adjacent values of Xj; large and negative when Xi and neighboring values Xj are dissimilar; and approximates to zero when no spatial autocorrelation exists between Xi and neighboring Xj. [@Premo2004]
I <- spdep::localmoran(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))

# local Getis G
# > G is positive when the sum of Xj within d [lag distance] of i is relatively large, negative when the sum of Xj within d of i is relatively small, and approximates zero when the sum of Xj within d of i is intermediate by comparison. [@Premo2004]
G <- spdep::localG(spX$Date..AD., listw=nb2listw(X_nb75, style="W"))
```

## 5. Results

```{r}
spI <- maptools::spCbind(spX, as.data.frame(I))

# ggplot2
ggplot(data=as.data.frame(spI), aes(x=Easting..km., y=Northing..km.)) + geom_point(aes(colour=Ii, size=abs(Ii))) + scale_colour_gradient2(midpoint=0) + scale_radius() + coord_fixed(ratio=1) + theme_bw() + xlab("Km East") + ylab("Km North") + ggtitle("Fig.2")
```

> Fig.2 presents standardized Ii variates at a lag distance of 75 km...

```{r}
# fig.2
## bubble plot
bubble(spI, "Ii", fill=TRUE, col=c("grey","black"), main="Fig.2", xlab="Km East", ylab="Km North")
```

> Fig.3 presents standardized Gi scores at a lag distance of 75 km...

```{r}
# fig.3
```


## References